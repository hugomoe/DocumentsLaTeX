\subsection{Pseudo-code pour la décomposition d'une homographie}
 
 On rappelle que dans les algorithmes qui suivent, on prend la convention suivante : $H = \pmatrice{a&b&p\\c&d&q\\r&s&t}$ est la matrice carrée de taille 3 (ou l'application homographique) telle que si $img$ est l'image d'entrée et $img_f$ est l'image de sortie, $img_f(x) = img(H(x))$. Ainsi, la décomposition $H \sim T_{c} R_{\psi}  \tilde H R_{\phi}$ est exécutée de gauche à droite. On notera cette décomposition $A \tilde H B$, et ces trois matrices seront les objets renvoyés par $decomposition$.
 
 Cet algorithme $decomposition$ (algorithme \ref{pseudoCodeDecompo}) présente la décomposition correspondant aux schémas \ref{SchemaEtapesDecompoGeometrique}. Arbitrairement, on choisit le degré de liberté de sorte à annuler une des translations (verticale ou horizontale) de $T_c$ : pour cela, on rappelle que $(x_2,y_2)$ (nommés $t_0,t_1$ dans l'algorithme) doivent vérifier
 \[\Delta_H(x_2 , y_2 ) \stackrel{\text{déf}}{=} R ((rc+sd)-(r^2 + s^2)y_2) - S ((ar+sb)-(r^2 + s^2 )x_2) = 0 \]
 On prend donc $t_0 = x_2 = -\frac{\Delta_H(0,0)}{(r^2+s^2)S}, t_1 = y_2 = 0$ ou $t_0 = x_2 = 0, t_1 = y_2 = -\frac{\Delta_H(0,0)}{(r^2+s^2)R}$, en choisissant de sorte à ne pas diviser par zéro.
 
   \begin{algorithme}
     \label{pseudoCodeDecompo}
     \caption{$decomposition(H)$}
     \KwData{Une matrice d'homographie $H \in \mathcal M_{3,3}$}
     \eIf{$as-br\neq0$}{
      $t_0 = -\frac{\Delta_H(0,0)}{(r^2+s^2)S}$\;
      $t_1 = 0$\;
     }{
      $t_0 = 0$\;
      $t_1 = -\frac{\Delta_H(0,0)}{(r^2+s^2)R}$\;
     }
     $N_\phi = \sqrt{r^2+s^2}$\;
     $R_\phi = \pmatrice{
      \frac{r}{N_\phi} & \frac{s}{N_\phi} & 0\\
      -\frac{s}{N_\phi} & \frac{r}{N_\phi} & 0\\
      0 & 0 & 1}$\;
     $N_\psi = \sqrt{((a+t_0r)s-(b+t_0s)r)^2+((c+t_1r)s-(d+t_1s)r)^2}$\;
     $R_\psi = \pmatrice{
      \frac{(c+t_1r)s-(d+t_1s)r}{N_\psi} & \frac{(a+t_0r)s-(b+t_0s)r}{N_\psi} & 0\\
      -\frac{(a+t_0r)s-(b+t_0s)r}{N_\psi} & \frac{(c+t_1r)s-(d+t_1s)r}{N_\psi} & 0\\
      0 & 0 & 1}$\;
     $A = T^{-1}R_\psi$\;
     $\tilde H = \pmatrice{
      -\frac{((a+t_0r)(d+t_1s)-(b+t_0s)(c+t_1r))N_\phi}{N_\psi} & 0 & \frac{p'((c+t_1r)s-(d+t_1s)r)-q'((a+t_0r)s-(b+t_0s)r)}{N_\psi}\\
      0 & -\frac{N_\psi}{N_\phi} & \frac{p'((a+t_0r)s-(b+t_0s)r)+q'((c+t_1r)s-(d+t_1s)r)}{N_\psi}\\
      N_\phi & 0 & t'}$\;
     $B = R_\phi$\;
     \KwRet{$A,\tilde H,B$}
   \end{algorithme}
   Dans une implémentation pratique, on n'inverse pas la matrice $H$ pour obtenir les valeurs de $t_0$ et $t_1$, car les quantités susmentionnées se simplifient en
 \[\frac{\Delta_H(0,0)}{(r^2+s^2)S} = \frac{(as-br)(ar+bs)+(cs-dr)(cr+ds)}{(r^2+s^2)(as-br)}\]
 \[\frac{\Delta_H(0,0)}{(r^2+s^2)R} = \frac{(as-br)(ar+bs)+(cs-dr)(cr+ds)}{(r^2+s^2)(cs-dr)}\]
 De plus, en pratique, la condition $as-br=0$ n'est jamais vérifiée, on préfère donc la remplacer par une condition $as-br<cs-dr$.

\subsection{Traitement d'une homographie quelconque}
 
 À partir de la décomposition, en utilisant les algorithmes de traitement d'homographie et d'affinités des sections suivantes, on peut donc traiter une homographie quelconque :
 
 On crée des images intermédiaires pour entre chaque étape (entre affinité et homographie et entre homographie et affinité) d'une taille suffisamment grande pour contenir toute l'image entre les transformations. Chaque image intermédiaire représente un rectangle du plan qui peut être caractérisé par ses tailles (largeur, hauteur) et les coordonnées $(\mu,\nu)$ de son origine (son premier pixel supérieur gauche). Cela permet de ne conserver que la portion du plan qui contient l'information, et donc de ne traiter les translations qu'en changeant les paramètres $\mu$ et $\nu$.
 
 Ainsi, la première image intermédiaire sera le plus petit rectangle du plan contenant le résultat de la première affinité. L'homographie unidirectionnelle pouvant être effectuée de n'importe quelle rectangle du plan vers n'importe quel autre, elle ne rentre pas en compte pour déterminer les tailles intermédiaires. La seconde image intermédiaire sera le plus petit rectangle du plan contenant l'antécédent de la fenêtre de sortie par la dernière rotation.
 
 On a donc deux images intermédiaires ; leurs tailles et les coordonnées de leurs origines sont déterminées en calculant le plus petit rectangle contenant $A^{-1}(rect_i)$ et le plus petit rectangle contenant $B(rect_f)$ (où $rect_i$ est le rectangle du plan où est stockée l'image initiale (sa taille est celle de l'image d'entrée, son origine a pour coordonnées $(\mu,\nu)=(0,0)$), et$rect_f$ est le rectangle du plan où sera stockée l'image finale (sa taille est celle de la fenêtre de sortie, son origine a pour coordonnées $(\mu,\nu)=(0,0)$)).
 
 \begin{prop}
  La taille des images intermédiaires est bornée indépendamment de l'homographie traitée.
 \end{prop}
 En effet, la composante de translation de $A$ et $B$ est prise en compte en changeant $(\mu,\nu)$ ; le changement de taille ne tient donc plus compte que de leur partie linéaire, qui est une rotation. Si les tailles initiales et finales sont fixées (par l'image d'entrée et la fenêtre de sortie), la taille d'une image intermédiaire est au plus $\sqrt{2}$ fois plus grande (à 1 pixel près) que la plus grande des dimensions initiales et finales.
