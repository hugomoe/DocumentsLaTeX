%pseudo-code mipmap/ripmap
%Hugo s'en charge
\sse{Pseudo-code pour le Mipmap}

\ssse{Conventions}

Un Mipmap est un tableau à trois dimensions, avec les deux axes usuels et une profondeur $d$.
Ainsi $M[3]$ est le carré $4$ fois moins haut que l'image d'origine. On note $n=2^l$ la taille de l'image (qui est supposée carrée). On note $D$ la fonction de distance (à deux arguments).

On utilise la convention suivante pour la profondeur : 
\begin{itemize}
\item Si $d = 1$ alors on considère l'image d'origine.
\item Si $d = n$ alors on considère l'image d'un pixel qui est la moyenne de l'image.
\end{itemize}
%ici mettre une image symbolique, schéma de la pyramide avec u,v et d

En pratique, on a périodisé l'image.

\ssse{Pseudo-code}

Ici on a juste le corps de la fonction, ainsi la fonction de distance et la construction du mipmap ne sont pas précisées, ils le sont dans les sections suivantes.
\medbreak
\medbreak
\begin{algorithm}[H]
\caption{$mainFunction(img,H,img_f)$}
\KwData{Une image $img[1..n][1..n]$, Une homographie $H = \left( \begin{array}{ccc} a &b & p\\ c & d & q \\ r & s & t\\ \end{array}\right)$, une fenêtre d'arrivée $img_f[1..m][1..m]$}
$M=builtMipMap(img)$ \;%Faire le mip-mapping de $img$ noté $M$\;
Calculer l'homographie inverse $H^{-1}$ (et calculer la fonction $D$ de $x,y$ en même temps)\;
\For{$(x,y) \in \llb 1,m \rrb^2$}{
Calculer $d=D(x,y)$ \;%préciser les équations
$I[x][y] = evalPixel(H^{-1}(x,y),d,M)$\;
}
\KwRet{I}
\end{algorithm}

\medbreak
\medbreak
L'interpolation trilinéaire :
\medbreak
\medbreak

\begin{algorithm}[H]
\caption{$evalPixel((u,v),d,M)$}
\KwData{Des coordonnées $(u,v) \in \mb{R}^2$, une distance $d \in \mb{R}$, un mipmap $M[1..l]$ où chaque élément est un image}
\uIf{$d\leq1$}{\KwRet{$bilinearMipMap(u,v,M[1])$}}
\uElseIf{$d>l$}{\KwRet{$M[l][1][1]$}}
\Else{Trouver $m \in \mb{N}$ tels que $2^m \leq d < 2^{m+1}$\;
$a=bilinearMipMap(\frac{u}{2^{m-1}}, \frac{v}{2^{m-1}},M[m])$\;
$b= bilinearMipMap(\frac{u}{2^{m}}, \frac{v}{2^{m}},M[m+1])$\; 
\KwRet{$ (m+1 - \log (d)) a + (\log (d) - m) b$}}

\end{algorithm}

\medbreak
\medbreak
Ici l'interpolation bilinéaire, au niveau $d$.
\medbreak
\medbreak

\begin{algorithm}[H]
\caption{$bilinearMipMap((u,v),M)$}
\KwData{Des coordonnées $(u,v) \in \mb{R}^2$, une image tirée du mipmap $img[1..k][1..k]$}
$u'=floor(u)$\;
$v' = floor(v)$\;
$x=u-u'$\;
$y = v-v'$\;
\KwRet{$(1-x)(1-y)*img[u'][v'] + (1-x)y*img[u'][v'+1] + x(1-y)*I[u'+1][v']+xy*img[u'+1][v'+1]$}\;
\end{algorithm}

\medbreak
\medbreak
Ce n'est qu'un algorithme générique, nous allons maintenant voir comment le spécifier pour permettre une implémentation réelle. Il faut examiner la construction du mipmap. On s'est intéressé au problème de la fonction de distance dans la partie sur les méthodes existantes. %a voir mettre une reference / un lien...

\ssse{Construction du mipmap}

Voici un exemple naïf de construction d'un mipmap. On fait simplement la moyenne des quatre pixels concernés.
 \medbreak
  \medbreak
 \begin{algorithm}[H]
 \caption{$buildMipMap(img)$}
 \KwData{Une image $img[1..n][1..n]$ (où $n = 2^l$)}
 \For{$(i,j)\in \llb1,n\rrb^2$}{
 	$M[1][i][j]=img[i][j]$\;
 }
 \For{$u \in \llb 2,l+1\rrb$}{
 	\For{$(i,j)\in \llb1,\frac{n}{2^{u-1}}\rrb^2$}{
		$M[u][i][j]=\frac{M[u-1][2i][2j][u-1]+M[u-1][2i-1][2j]+M[u-1][2i][2j-1]+M[u-1][2i-1][2j-1]}{4}$\;
	}
 }
 \end{algorithm}
 \medbreak
  \medbreak
 Ce n'est pas une bonne méthode, en pratique on a fait précédé chaque moyennage par un filtrage gaussien de l'image. C'est une phase de précalcul, on tolère le fait qu'elle soit relativement coûteuse.  


\sse{Le ripmap}

\ssse{Conventions}

Le ripmap $R$ et quadri-dimensionnel  : les deux premiers indices indiquent le rectangle, les deux autres indiquent le pixel du rectangle. Ainsi appeler $R[2][4]$ appelle une image simple, de largeur $\frac{1}{2}$ et de hauteur $\frac{1}{16}$ de l'image d'origine. On suppose l'image de départ carrée de taille $n=2^l$.

\ssse{Pseudo-code pour le ripmap}

La fonction principale, très similaire au ripmap.
\medbreak
\medbreak
\begin{algorithm}[H]
\caption{$mainFunction(img,H,img_f)$}
\KwData{Une image $img[1..n][1..n]$, Une homographie $H = \left( \begin{array}{ccc} a &b & p\\ c & d & q \\ r & s & t\\ \end{array}\right)$, une fenêtre d'arrivée $img_f[1..m][1..m]$}
$R = buildRipMap(img)$\;
Calculer l'homographie inverse $H^{-1}$ (et précalculer les fonctions $\frac{\dr u}{\dr x},\frac{\dr u}{\dr y},\frac{\dr v}{\dr x},\frac{\dr v}{\dr y}$ de $x,y$ en même temps)\;
\For{$(x,y) \in \llb 1,m \rrb^2$}{
Calculer $d_1=|\frac{\dr u}{\dr x}(x,y)|+|\frac{\dr u}{\dr y}(x,y)|$ \;
Calculer $d_2=|\frac{\dr v}{\dr x}(x,y)|+|\frac{\dr v}{\dr y}(x,y)|$\;
Calculer $c_1 = \min(0,\frac{\dr u}{\dr x}(x,y))+\min(0,\frac{\dr u}{\dr y}(x,y))$\;
Calculer $c_2 = \min(0,\frac{\dr v}{\dr x}(x,y))+\min(0,\frac{\dr v}{\dr y}(x,y))$\;
$img_f[x][y] = evalPixel(H^{-1}(x,y)+(c_1,c_2),d_1,d_2,R)$\;
}
\KwRet{I}
\end{algorithm}

\medbreak
\medbreak

L'interpolation bilinéaire entre les rectangles.
Les $m_{ij}$ permettent de simplifier l'écriture des cas ou l'une des distances est trop grande ou trop petite :

\medbreak
\medbreak

\begin{algorithm}[H]
\caption{$evalPixel((u,v),d_1,d_2,M)$}
\KwData{Des coordonnées $(u,v) \in \mb{R}^2$, des distances $d_1,d_2 \in \mb{R}$, un Ripmap $R[1..l][1..l]$ constitué d'images}
\For{$i\in \llb 1,2\rrb$}{
$x_i = \floor{\log_2(d_i)}$\;
\uIf{$x_i \leq 1$}{$m_{i1}=m_{i2} = 1$\;}
\uElseIf{$x_i\geq l$}{$m_{i1}=m_{i2}=l$\;}
\Else{$m_{i1} = x_i -1$ \;$m_{i2} = x_i$\;}
}

$a=bilinearMipMap(\frac{u}{2^{m_{11}}},\frac{v}{2^{m_{21}}},R[m_{11}+1][m_{21}+1])$\;
$b=bilinearMipMap(\frac{u}{2^{m_{12}}},\frac{v}{2^{m_{21}}},R[m_{12}+1][m_{21}+1])$\;$c=bilinearMipMap(\frac{u}{2^{m_{11}}},\frac{v}{2^{m_{22}}},R[m_{12}+1][m_{22}+1])$\;
$d=bilinearMipMap(\frac{u}{2^{m_{12}}},\frac{v}{2^{m_{22}}},R[m_{12}+1][m_{22}+1])$\;

$x = m_{12} - \log_2(d_1)$\;
$y = m_{22} - \log_2(d_2)$\;

\KwRet{$xy * a + (1-x)y * b + x(1-y) * c + (1-x)(1-y) * d$\;}
\end{algorithm}


\ssse{La construction du ripmap}

On présente un algorithme naïf de construction de ripmap.
\medbreak
\medbreak
\begin{algorithm}[H]
\caption{buildRipMap(img)}
\KwData{une image $img[1..n][1..n]$, où $n = 2^l$}
$R[1][1] = img$\;
\For{$j\in\llb 2,l\rrb$}{
	\For{$(u,v)\in \llb 1,n\rrb \times \llb1,\frac{n}{2^{j-1}}\rrb$}{
		$R[1][j][u][v] = \frac{R[1][j-1][u][2v] + R[1][j-1][u][2v-1]}{2}$\;
	}
}

\For{$j\in\llb 1,l\rrb$}{
\For{$i\in\llb 2,l\rrb$}{
\For{$(u,v)\in \llb 1,\frac{n}{2^{i-1}}\rrb \times \llb1,\frac{n}{2^{j-1}}\rrb$}{
		$R[i-1][j][u][v] = \frac{R[i-1][j][2u][v] + R[i-1][j][2u-1][v]}{2}$\;
	}}}
\KwRet{$R$}
\end{algorithm}
\medbreak
\medbreak
Dans la pratique on a filtré à l'aide d'un filtre gaussien dans la direction où l'on compresse, et ce à chaque étape.
\medbreak
\medbreak
\begin{algorithm}[H]
\caption{buildRipMapGaussien(img)}
\KwData{une image $img[1..n][1..n]$, où $n = 2^l$}
$R[1][1] = img$\;
\For{$j\in\llb 2,l\rrb$}{
	\For{$(u,v)\in \llb 1,n\rrb \times \llb1,\frac{n}{2^{j-1}}\rrb$}{
		$R[1][j][u][v] = convolutionHorizontale(R[1][j-1])[u][2v]$\;
	}
}

\For{$j\in\llb 1,l\rrb$}{
\For{$i\in\llb 2,l\rrb$}{
\For{$(u,v)\in \llb 1,\frac{n}{2^{i-1}}\rrb \times \llb1,\frac{n}{2^{j-1}}\rrb$}{
		$R[i-1][j][u][v] = convolutionVerticale(R[i-1][j])[2u][v]$\;
	}}}
\KwRet{$R$}
\end{algorithm}
\medbreak
\medbreak
Où les fonctions $convolution$ convolent dans la direction indiquée par une gaussienne d'écart-type $1,4$ (se reporter à \cite{morel2011sift})


