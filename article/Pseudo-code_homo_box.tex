%contient le pseudo-code de homo-box, simple et avec triple intégrale

\sse{Traitement de l'homographie particulière}

\ssse{Conventions}

Les images sont des matrices. On a ignoré les éventuelles multiples niveaux de couleurs (qui seront traités indépendamment).

Il y a en faites une origine sur les images (pour pouvoir faire des translations instantanées).

\medbreak
Les fonctions $imageIntegrale$ construisent simplement l'image intégrale de la ligne/colonne correspondante, on ne les a pas précisées.

On suppose qu'on dispose d'une fonction $cubicInterpolation$ qui réalise l'interpolation à l'aide de la valeur en quatre points et de la position à interpoler.

On peut remplacer les appels à $imageIntegrale$ par trois appels à $imageIntegrale$ (pour utiliser l'image triple intégrale) auquel cas il faudra appeler $interpole3$ au lieu de $interpole$. De plus il faut déclarer une image intégrale plus grande que celle de départ, en effet quand on intègre trois fois les valeurs au delà de la dernière ne sont plus nulles, ni même constantes.

\ssse{Corps de l'algorithme}

\begin{algorithm}[H]
\caption{$applyHomography(img,imgf,H)$}
\KwData{Une image de départ $img[1..w][1..h]$, une image d'arrivé $img_f[1..w_f][1..h_f]$, une homographie $H = \left( \begin{array}{ccc} a_1 & 0 & t_1 \\ 0 & a_2 & t_2 \\  \lambda & 0 & t_3\\ \end{array} \right)$}
$f_1 = x\mapsto \frac{a_1x + t_1}{\lambda x + t_3}$ \;
$f_2 = x,y\mapsto \frac{a_2y + t_2}{\lambda x + t_3}$ \;
\For{$j \in \llbracket 1, h \rrbracket$}{
	$iimgw = imageIntegrale(j^e \text{ colonne de } img)$ \;
	\For{$i \in \llbracket 1, w_f \rrbracket$}{
		$x = f_1(i)$\;
		$d = |f_1'(i)|$\;
		$img_{aux}(i,j) = interpole(iimgw,x,d)$\;
	}
}
\For{$i \in \llbracket 1, w_f \rrbracket$}{
	$iimgh = imageIntegrale(i^e \text{ ligne de } img_{aux})$\;
	$d=\frac{\dr}{\dr y} f_2(i,0)$ (indépendant de $j$)\;
	\For{$j \in \llbracket 1, h_f \rrbracket$}{
		$y=f_2(i,j)$\;
		$img_f(i,j)=interpole(iimgh,y,d)$\;
	}
}
\end{algorithm}

\ssse{Interpolation à l'aide de l'image intégrale}

Une première version naive. La fonction $interpoleInt$ renvoie la moyenne sur un segment de longueur $d$ est d'origine $i$.

Nous n'avons pas réglé les cas où $interpoleInt$ n'est pas définie.

\begin{algorithm}[H]
\caption{$interpole(imgint,u,d)$}
\KwData{Une image intégrée une fois $imgint[1..n]$, une position $x\in\mb{R}$, une distance $d\in\mb{R}$}
$u=u-\frac{d}{2}$\;
$id=floor(d)$\;
$iu=floor(u)$\;
$x = d-id$\;
$y = u-iu$\;
\uIf{$id\leq 0$}{
$a=interpoleInt(imgint,iu,1)$\;
$b=interpoleInt(imgint,iu+1,1)$\;
\KwRet{$(1-y)*a + y*b$}
}
\Else{$a=interpoleInt(imgint,iu,id)$\;
$b=interpoleInt(imgint,iu+1,id)$\;
$c=interpoleInt(imgint,iu,id+1)$\;
$d=interpoleInt(imgint,iu+1,id+1)$\;
\KwRet{$(1-x)(1-y)*a+(1-x)y*b+x(1-y)*c+xy*d$}}
\end{algorithm}

\begin{algorithm}[H]
\caption{$interpoleInt(imgint,i,d)$}
\KwData{Une image intégrée une fois $imgint[1..n]$, une position $i\in\mb{N}$, une distance $d\in\mb{N}$}
\uIf{$i+d-1<0$}{\KwRet{$0$}}
\uElseIf{$i<1$}{\KwRet{$\frac{imgint[i+d-1]}{d}$}}
\Else{\KwRet{$\frac{imgint[i+d-1]-imgint[i-1]}{d}$}}
\end{algorithm}


\ssse{A l'aide de la convolé de trois portes}

Notons $g_3$ la convolé de trois portes. On a $g_3'' = \mathds{1}_{[-\frac{3}{2} -\frac{1}{2}]}-2*\mathds{1}_{[-\frac{1}{2},\frac{1}{2}]}+\mathds{1}_{[\frac{1}{2},\frac{3}{2}]}$.
Ainsi en notant $F$ l'intégrale de l'image et $F_2$ l'intégrale seconde de l'image, on a $\int f g_3 = \int F g_3' = \int F_2 g_3''$.

Ainsi on peut prendre plutôt : 

\begin{algorithm}[H]
\caption{$interpole3(imgint3,u,d)$}
\KwData{Une colonne/ligne d'une image intégrée trois fois $imgint3[1..n]$, une position $u\in\mb{R}$, une distance $d\in\mb{R}$}
$id=floor(d)$\;
$iu=floor(u)$\;
$x = d-id$\;
$y = u-iu$\;
On déclare deux tableaux $Y1[1..4],Y2[1..4]$\;
\For{$i\in\llb-1,2\rrb$}{
$Y1[i+2]=interpoleTripleInt(imgint3,iu+i,id)$\;
$Y2[i+2]=interpoleTripleInt(imgint3,iu+i,id+1)$\;
}
$a=cubicInterpolation(Y1,y)$\;
$b=cubicInterpolation(Y2,y)$\;
\KwRet{$(1-x)*a+x*b$}
\end{algorithm}

\begin{algorithm}[H]
\caption{$interpoleTripleInt(imgint3,i,d)$}
\KwData{Une colonne/ligne d'une image intégrée trois fois $imgint3[1..n]$, une position $i\in\mb{N}$, une distance $d\in\mb{N}$}
$a=interpoleInt(imgint3,i-d,d)$\;
$b=interpoleInt(imgint3,i,d)$\;
$c=interpoleInt(imgint3,i+d,d)$\;
\KwRet{$\frac{a-2*b+c}{d^2}$}
\end{algorithm}

\ssse{Complexité}

La fonction $interpoleInt$ est clairement en temps constant. Ainsi on en conclu sans problème que $interpole$ et $interpole3$ le sont aussi. Dans $applyHomography$ on a ainsi des boucles sur des fonctions constantes et des intégrations. Ainsi la première boucle est en $O(h(w+w_f))$ car l'appel de $imageIntegrale$ se fait sur une colonne de taille $w$. De même la deuxième boucle est en $O(w_f(h_f+h))$.
\medbreak
%a verifier
Ainsi en admettant que le rapport largeur sur longueur est borné, l'algorithme est en $O(n_1+n_2)$ où $n_1$ est la taille de l'image de départ et $n_2$ celle de l'image d'arrivée. On remarque que cela ne dépend pas des coefficients de l'homographie.

